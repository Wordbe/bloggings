# 파이썬의 동시성, 병렬성 프로그래밍



# 동시작업 처리

- 스레드 사용 : `threading`
  - 선점형 멀티태스킹 (pre-emptive multitasking) - 운영체제가 스레드를 언제든지 멈추고 다른 스레드를 진행시킬 수 있다.
- 태스크 사용 : `asyncio`
  - 협력식 멀티태스킹 (cooperative multitasking) - 각 태스크가 언제 스위칭 될 준비가 되었는지 명시해주어야 한다.
- 프로세스 사용 : `multiprocessing` - 완전히 병렬적으로 작업처리
  - 멀티프로세싱 - 다수의 프로세서 사용하여 병렬적으로 실행

<br />

# CPU 바운드, I/O 바운드

| CPU 바운드 프로세스                                 | I/O 바운드 프로세스                                          |
| --------------------------------------------------- | ------------------------------------------------------------ |
| 프로그램이 CPU 계산 작업에 대부분 시간 사용         | 프로그램이 네트워크 커넥션, 디스크 등 외부 장치와 통신하는데 대부분 시간 사용 |
| 같은 시간에 더 많은 계산을 하게 해서 속도 개선 가능 | 외부 응답 대기시간을 잘 겹치게 하면 속도 개선 가능           |

<br />

# Threading 버전

- 문제
  - 스레드는 알기 어려운 방법으로 서로 상호작용한다. 스레드 간 공유되는 데이터가 올바르게 사용되고 있는지 항상 확인해야 한다.
  - 경쟁 상태 (race condition) 발생하여 버그를 만들고, 이를 디버깅하기가 까다롭다.

<br />

# 순차적 버전

- 우리가 아는 절차지향형 순차적인 실행 코드이다.

<br />

# Asyncio 버전

태스크 상태

- 준비 : 작업을 실행할 준비가 되어있음
- 대기 : 외부 작업이 끝나기를 대기하고 있음

이벤트 루프

- 각 태스크의 상태를 알고, 태스크를 언제 어떻게 실행시킬지 제어한다.
- 태스크가 직접 의도적으로 제어권을 넘길 때까지 태스크 간 스위칭이 일어나지 않는다. 따라서 `threading` 에서 발생하는 자원 공유 문제를 생각하지 않아도 된다.

async, await

- `await` 키워드는 태스크가 이벤트루프에게 다시 제어권을 반환할 수 있게 해준다.



장점

- 스레드를 만드는 것보다 태스크가 훨씬 더 작은 자원과 시간을 소모한다.

문제

- 동시성을 지원하는 라이브러리가 필요하다. `requests ` 대신 `aiohttp` 모듈 사용
- 어느 한 태스크가 협력하지 않으면, 협력적 멀티태스킹의 이점이 모두 사라진다. 한 태스크가 제어권을 이벤트 루프에게 넘겨주지 않으면 외부에서 뚫고 들어갈 방법이 없다.

<br />

# Multiprocessing 버전

- 컴퓨터가 가진 여러 개의 CPU 코어를 모두 사용할 수 있다.
- `multiprocessing` 모듈은 GIL (Global Interpreter Lock) 을 우회해서 코드를 여러 CPU 에 걸쳐 사용 간으하게 만들어준다. 새로운 파이썬 인터프리터를 각 CPU 에서 실행할 수 있도록 만들어 프로그램의 일부를 실행하도록 한다.
- 새로운 인터프리터를 띄우는 작업은 스레드를 생성하는 것보다 훨씬 무겁고 제한적이며 어려움이 많지만, 올바르게 사용한다면 프로그램의 성능을 개선할 수 있다.
  - I/O 요청들을 병렬적으로 만들어 오는 이득보다, 프로세스를 생성하고 정리하는데 드는 비용이 더 크면 오히려 성능이 악화될 수 있다.

장점

- 비교적 구현하기 쉽다.
- 모든 CPU 를 사용할 수 있다.

단점

- 전역 변수로 Session 을 할당한 부분이 거슬린다. 물론 각 파이썬 인터프리터에 별개의 메모리에 저장되기 때문에 공유되진 않는다.
- multiprocessing 은 I/O 바운드 작업을 위해 있는게 아니다. 성능 향상이 없을 수 있다.



# CPU 바운드

순차적 버전, threading, asyncio 는 한 CPU 에서 실행된다.

따라서 CPU 바운드 작업의 경우, 스레드나 태스크를 사용한다고 해서 성능 향상이 나타나지 않고, 오히려 자원 생성비용 때문에 더 느려진다.

하나의 CPU 가 I/O 바운드와 같이 기다리는 작업은 동시에 할 수 있지만, CPU 를 사용하는 작업은 동시에 할 수 없기 때문이다.

<br />

multiprocessing 은 이렇게 무거운 CPU 바운드 작업을 여러 CPU 에 나눠서 처리하기 위해 고안되었다.

성능 개선이 가능하다.

문제점

- 작업을 분할하여 각 프로세서가 작업하도록 하는 것은 때때로 어려울 수 있다.
- 대부분 프로세스의 경우 통신이 필요할텐데, 순차적 프로그램에서는 고민하지 않아도 될 추가적인 복잡성이 생긴다.

<br />

# 결론

- 파이썬 커뮤니티에서 제시하는 일반 규칙 : I/O 바운드 동시 작업에 대해 가능하면 asyncio 를 쓰고, threading 은 꼭 필요할 때 써라.
- CPU 바운드 동시 작업은 multiprocessing 을 사용하자.

<br />

# 참고자료

https://nachwon.github.io/asyncio-futures/

